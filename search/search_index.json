{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"REST Framework XML XML support for Django REST Framework Overview XML support extracted as a third party package directly from the official Django REST Framework implementation. It requires the defusedxml package only because it safeguards against some security issues that were discovered. Note : XML output provided is an ad-hoc format that isn't formally described. If you have specific XML requirements you'll need to write your own XML parsers/renderers in order to fully control the representation. Requirements Python 3.5+ Django 2.2+ Django REST Framework 3.11+ Installation Install using pip ... $ pip install djangorestframework-xml Example REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework_xml.parsers.XMLParser', ), 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework_xml.renderers.XMLRenderer', ), } You can also set the renderer and parser used for an individual view, or viewset, using the APIView class based views. from rest_framework import routers, serializers, viewsets from rest_framework_xml.parsers import XMLParser from rest_framework_xml.renderers import XMLRenderer class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ('url', 'username', 'email', 'is_staff') class UserViewSet(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializer parser_classes = (XMLParser,) renderer_classes = (XMLRenderer,) Sample output <?xml version=\"1.0\" encoding=\"utf-8\"?> <root> <list-item> <url>http://127.0.0.1:8000/users/1/.xml</url> <username>jpadilla</username> <email>jpadilla@example.com</email> <is_staff>True</is_staff> </list-item> </root> Testing Install testing requirements. $ pip install -e '.[dev]' Run with pytest. $ pytest You can also use the excellent tox testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run: $ tox Documentation To build the documentation, you'll need to install mkdocs . $ pip install mkdocs To preview the documentation: $ mkdocs serve Running at: http://127.0.0.1:8000/ To build the documentation: $ mkdocs build","title":"Home"},{"location":"#rest-framework-xml","text":"XML support for Django REST Framework","title":"REST Framework XML"},{"location":"#overview","text":"XML support extracted as a third party package directly from the official Django REST Framework implementation. It requires the defusedxml package only because it safeguards against some security issues that were discovered. Note : XML output provided is an ad-hoc format that isn't formally described. If you have specific XML requirements you'll need to write your own XML parsers/renderers in order to fully control the representation.","title":"Overview"},{"location":"#requirements","text":"Python 3.5+ Django 2.2+ Django REST Framework 3.11+","title":"Requirements"},{"location":"#installation","text":"Install using pip ... $ pip install djangorestframework-xml","title":"Installation"},{"location":"#example","text":"REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework_xml.parsers.XMLParser', ), 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework_xml.renderers.XMLRenderer', ), } You can also set the renderer and parser used for an individual view, or viewset, using the APIView class based views. from rest_framework import routers, serializers, viewsets from rest_framework_xml.parsers import XMLParser from rest_framework_xml.renderers import XMLRenderer class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ('url', 'username', 'email', 'is_staff') class UserViewSet(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializer parser_classes = (XMLParser,) renderer_classes = (XMLRenderer,)","title":"Example"},{"location":"#sample-output","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <root> <list-item> <url>http://127.0.0.1:8000/users/1/.xml</url> <username>jpadilla</username> <email>jpadilla@example.com</email> <is_staff>True</is_staff> </list-item> </root>","title":"Sample output"},{"location":"#testing","text":"Install testing requirements. $ pip install -e '.[dev]' Run with pytest. $ pytest You can also use the excellent tox testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run: $ tox","title":"Testing"},{"location":"#documentation","text":"To build the documentation, you'll need to install mkdocs . $ pip install mkdocs To preview the documentation: $ mkdocs serve Running at: http://127.0.0.1:8000/ To build the documentation: $ mkdocs build","title":"Documentation"},{"location":"parsers/","text":"Parsers Setting the parsers The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow requests with XML content. REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework_xml.parsers.XMLParser', ) } You can also set the parsers used for an individual view, or viewset, using the APIView class based views. from rest_framework.response import Response from rest_framework.views import APIView from rest_framework_xml.parsers import XMLParser class ExampleView(APIView): \"\"\" A view that can accept POST requests with XML content. \"\"\" parser_classes = (XMLParser,) def post(self, request, format=None): return Response({'received data': request.DATA}) Or, if you're using the @api_view decorator with function based views. @api_view(['POST']) @parser_classes((XMLParser,)) def example_view(request, format=None): \"\"\" A view that can accept POST requests with XML content. \"\"\" return Response({'received data': request.DATA}) API Reference XMLParser Parses REST framework's default style of XML request content. Note that the XML markup language is typically used as the base language for more strictly defined domain-specific languages, such as RSS , Atom , and XHTML . If you are considering using XML for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type. Requires the defusedxml package to be installed. .media_type : application/xml","title":"Parsers"},{"location":"parsers/#parsers","text":"","title":"Parsers"},{"location":"parsers/#setting-the-parsers","text":"The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow requests with XML content. REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework_xml.parsers.XMLParser', ) } You can also set the parsers used for an individual view, or viewset, using the APIView class based views. from rest_framework.response import Response from rest_framework.views import APIView from rest_framework_xml.parsers import XMLParser class ExampleView(APIView): \"\"\" A view that can accept POST requests with XML content. \"\"\" parser_classes = (XMLParser,) def post(self, request, format=None): return Response({'received data': request.DATA}) Or, if you're using the @api_view decorator with function based views. @api_view(['POST']) @parser_classes((XMLParser,)) def example_view(request, format=None): \"\"\" A view that can accept POST requests with XML content. \"\"\" return Response({'received data': request.DATA})","title":"Setting the parsers"},{"location":"parsers/#api-reference","text":"","title":"API Reference"},{"location":"parsers/#xmlparser","text":"Parses REST framework's default style of XML request content. Note that the XML markup language is typically used as the base language for more strictly defined domain-specific languages, such as RSS , Atom , and XHTML . If you are considering using XML for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type. Requires the defusedxml package to be installed. .media_type : application/xml","title":"XMLParser"},{"location":"renderers/","text":"Renderers Setting the renderers The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use XML as the main media type and also include the self describing API. REST_FRAMEWORK = { 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework_xml.renderers.XMLRenderer', ) } You can also set the renderers used for an individual view, or viewset, using the APIView class based views. from django.contrib.auth.models import User from rest_framework.response import Response from rest_framework.views import APIView from rest_framework_xml.renderers import XMLRenderer class UserCountView(APIView): \"\"\" A view that returns the count of active users in XML. \"\"\" renderer_classes = (XMLRenderer,) def get(self, request, format=None): user_count = User.objects.filter(active=True).count() content = {'user_count': user_count} return Response(content) Or, if you're using the @api_view decorator with function based views. @api_view(['GET']) @renderer_classes((XMLRenderer,)) def user_count_view(request, format=None): \"\"\" A view that returns the count of active users in XML. \"\"\" user_count = User.objects.filter(active=True).count() content = {'user_count': user_count} return Response(content) API Reference XMLRenderer Renders REST framework's default style of XML response content. Note that the XML markup language is used typically used as the base language for more strictly defined domain-specific languages, such as RSS , Atom , and XHTML . If you are considering using XML for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type. .media_type : application/xml .format : '.xml' .charset : utf-8 item_tag_name : list-item .root_tag_name : root","title":"Renderers"},{"location":"renderers/#renderers","text":"","title":"Renderers"},{"location":"renderers/#setting-the-renderers","text":"The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use XML as the main media type and also include the self describing API. REST_FRAMEWORK = { 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework_xml.renderers.XMLRenderer', ) } You can also set the renderers used for an individual view, or viewset, using the APIView class based views. from django.contrib.auth.models import User from rest_framework.response import Response from rest_framework.views import APIView from rest_framework_xml.renderers import XMLRenderer class UserCountView(APIView): \"\"\" A view that returns the count of active users in XML. \"\"\" renderer_classes = (XMLRenderer,) def get(self, request, format=None): user_count = User.objects.filter(active=True).count() content = {'user_count': user_count} return Response(content) Or, if you're using the @api_view decorator with function based views. @api_view(['GET']) @renderer_classes((XMLRenderer,)) def user_count_view(request, format=None): \"\"\" A view that returns the count of active users in XML. \"\"\" user_count = User.objects.filter(active=True).count() content = {'user_count': user_count} return Response(content)","title":"Setting the renderers"},{"location":"renderers/#api-reference","text":"","title":"API Reference"},{"location":"renderers/#xmlrenderer","text":"Renders REST framework's default style of XML response content. Note that the XML markup language is used typically used as the base language for more strictly defined domain-specific languages, such as RSS , Atom , and XHTML . If you are considering using XML for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type. .media_type : application/xml .format : '.xml' .charset : utf-8 item_tag_name : list-item .root_tag_name : root","title":"XMLRenderer"}]}